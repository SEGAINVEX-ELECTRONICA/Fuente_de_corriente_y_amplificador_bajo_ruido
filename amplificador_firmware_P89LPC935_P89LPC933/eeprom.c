/***********************************************************************
MODULE:    EEPROM
VERSION:   1.01
CONTAINS:  Routines for accessing the EEPROM on the Philips
           P89LPC935
COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
LICENSE:   May be freely used in commercial and non-commercial code
           without royalties provided this copyright notice remains
           in this file and unaltered
WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
           MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
           TO CHANGE THE CONTENTS OF THIS FILE
GENERATED: On "Dec 17 2014" at "12:39:44" by Code Architect 2.06
***********************************************************************/

// SFR description needs to be included
#include <reg935.h>
#include "eeprom.h"

// flag that indicates if the EEPROM is busy or not
static bit meeprombusy;

/***********************************************************************
DESC:    Initializes the EEPROM. Enables EEPROM interrupt
RETURNS: Nothing
CAUTION: Set EA to 1 after calling to enable all interrupts
************************************************************************/
void inicializa_eeprom  (  void  )
{
  // initially eeprom is not busy
  meeprombusy = 0;
  // set isr priority to 0
  // IP1 &= 0x7F;
  // IP1H &= 0x7F;
//  // enable eeprom interrupt
//  EIEE = 1;
  // disable eeprom interrupt
  EIEE = 0;
}
/***********************************************************************
DESC:    Reads a location in the EEPROM.
         If either global interrupts or the EEPROM interrupt is disabled
         then the function will return when the operation is complete.
         If global interrupts and the EEPROM interrupt are enabled, the
         function will return immediately and an interrupt will occur
         when the operation is complete.
RETURNS: The 8-bit value read if interrupts are disabled, otherwise
         0x00 will be returned.
CAUTION: inicializa_eeprom must be called first
************************************************************************/
unsigned char lee_eeprom
  (
  unsigned int address     // 9-bit address to read (0x000 - 0x1FF)
  )
{
  // wait for previous operation to complete
  while (meeprombusy);

  // eeprom now busy
  meeprombusy = 1;

  // store bit 8 of address
  // byte operation, clear interrupt flag
  DEECON = (address >> 8) & 0x01;
  // store bits 0-7 of address
  DEEADR = address & 0xFF;

  // if not using interrupt then poll for end of operation
  if (!EA || !EIEE)
  {
    // wait for operation to complete
    while (!(DEECON & 0x80));
    // eeprom no longer busy
    meeprombusy = 0;
    // return value
    return DEEDAT;
  }

  return 0x00;
}

/***********************************************************************
DESC:    Writes to a location in the EEPROM.
         If either global interrupts or the EEPROM interrupt is disabled
         then the function will return when the operation is complete.
         If global interrupts and the EEPROM interrupt are enabled, the
         function will return immediately and an interrupt will occur
         when the operation is complete.
RETURNS: Nothing
CAUTION: inicializa_eeprom must be called first
************************************************************************/
void escribe_eeprom(unsigned int address,/*(0x000 - 0x1FF)*/ unsigned char value)
{
  bit eacopy;
  // wait for previous operation to complete
  while (meeprombusy);
  // eeprom now busy
  meeprombusy = 1;
  // store bit 8 of address
  // byte operation, clear interrupt flag
  DEECON = (address >> 8) & 0x01;
  // disable interrupts
  eacopy = EA;
  EA = 0;
  // store value to write
  DEEDAT = value;
  // store bits 0-7 of address
  DEEADR = address & 0xFF;
  // restore interrupts
  EA = eacopy;
  // if not using interrupt then poll for end of operation
  if (!EA || !EIEE)
  {
    // wait for operation to complete
    while (!(DEECON & 0x80));
    // eeprom no longer busy
    meeprombusy = 0;
  }
}
///***********************************************************************
//DESC:    Writes a value to every location in a 64-byte row in
//         the EEPROM.
//         If either global interrupts or the EEPROM interrupt is disabled
//         then the function will return when the operation is complete.
//         If global interrupts and the EEPROM interrupt are enabled, the
//         function will return immediately and an interrupt will occur
//         when the operation is complete.
//RETURNS: Nothing
//CAUTION: inicializa_eeprom must be called first
//************************************************************************/
//void eeprom_fillrow
//  (
//   unsigned int address,    // 9-bit starting address of row
//                            // (64-byte aligned)
//   unsigned char value      // value to fill row with
//  )
//{
//  bit eacopy;
//
//  // wait for previous operation to complete
//  while (meeprombusy);
//
//  // eeprom now busy
//  meeprombusy = 1;
//
//  // store bit 8 of address
//  // row fill operation, clear interrupt flag
//  DEECON = ((address >> 8) & 0x01) | 0x20;
//  // disable interrupts
//  eacopy = EA;
//  EA = 0;
//  // store fill pattern
//  DEEDAT = value;
//  // store bits 0-7 of address (note bits 0-5 are ignored by device)
//  DEEADR = address & 0xFF;
//  // restore interrupts
//  EA = eacopy;
//
//  // if not using interrupt then poll for end of operation
//  if (!EA || !EIEE)
//  {
//    // wait for operation to complete
//    while (!(DEECON & 0x80));
//    // eeprom no longer busy
//    meeprombusy = 0;
//  }
//}
//
///***********************************************************************
//DESC:    Writes a value to every location in the EEPROM.
//         If either global interrupts or the EEPROM interrupt is disabled
//         then the function will return when the operation is complete.
//         If global interrupts and the EEPROM interrupt are enabled, the
//         function will return immediately and an interrupt will occur
//         when the operation is complete.
//RETURNS: Nothing
//CAUTION: inicializa_eeprom must be called first
//************************************************************************/
//void eeprom_fill
//  (
//  unsigned char value      // value to fill EEPROM with
//  )
//{
//  bit eacopy;
//
//  // wait for previous operation to complete
//  while (meeprombusy);
//
//  // eeprom now busy
//  meeprombusy = 1;
//
//  // bit 8 of address = 1
//  // block fill operation, clear interrupt flag
//  DEECON = 0x31;
//  // disable interrupts
//  eacopy = EA;
//  EA = 0;
//  // store fill pattern
//  DEEDAT = value;
//  // store anything to address register - value ignored by device
//  DEEADR = 0x00;
//  // restore interrupts
//  EA = eacopy;
//
//  // if not using interrupt then poll for end of operation
//  if (!EA || !EIEE)
//  {
//    // wait for operation to complete
//    while (!(DEECON & 0x80));
//    // eeprom no longer busy
//    meeprombusy = 0;
//  }
//}
//
///***********************************************************************
//DESC:    Erases a 64-byte row in the EEPROM.
//         If either global interrupts or the EEPROM interrupt is disabled
//         then the function will return when the operation is complete.
//         If global interrupts and the EEPROM interrupt are enabled, the
//         function will return immediately and an interrupt will occur
//         when the operation is complete.
//         Equivalent to eeprom_fillrow(address, 0x00);
//RETURNS: Nothing
//CAUTION: inicializa_eeprom must be called first
//************************************************************************/
//void eeprom_eraserow
//  (
//  unsigned int address      // 9-bit starting address of row
//                            // (64-byte aligned)
//  )
//{
//  eeprom_fillrow(address, 0x00);
//}
//
///***********************************************************************
//DESC:    Erases the EEPROM.
//         If either global interrupts or the EEPROM interrupt is disabled
//         then the function will return when the operation is complete.
//         If global interrupts and the EEPROM interrupt are enabled, the
//         function will return immediately and an interrupt will occur
//         when the operation is complete.
//         Equivalent to eeprom_fill(0x00);
//RETURNS: Nothing
//CAUTION: inicializa_eeprom must be called first
//************************************************************************/
//void eeprom_erase
//  (
//  void
//  )
//{
//  eeprom_fill(0x00);
//}
//
///***********************************************************************
//DESC:    EEPROM Interrupt Service Routine
//         Called when an EEPROM operation has completed
//         Uses register bank 3
//RETURNS: Nothing
//CAUTION: inicializa_eeprom must be called first
//************************************************************************/
//void eeprom_isr
//  (
//  void
//  ) interrupt 14 using 3
//{
//  // clear EEIF flag
//  DEECON &= ~0x80;
//  // eeprom no longer busy
//  meeprombusy = 0;
//}